# dfs 序
- 定义：对一棵树进行深度优先搜索时节点访问的时间。
- dfs 序并不唯一，不同的搜索顺序每个节点可能会有不同的 dfs 序值。

![](https://cdn.luogu.com.cn/upload/image_hosting/9w8ofg13.png)

性质：我们第一次搜索到 $u$ 节点时记录 $in_x$，在搜索完其子树以后返回时记录 $out_x$，那么有性质：在以 $u$ 为根的子树中，dfs 序的值是连续的（在 $[in_x, out_x]$ 之间，并且子树上的值是一一对应的）。

根据这个性质，我们便可以将许多树上操作利用 dfs 序变成区间操作，然后用线段树、树状数组、分块解决了。
```
void dfs(int u, int fa) {
    in[u] = ++ tot;
    //遍历子树
    out[u] = tot;
}
```

具体的，我们可以用 dfs 序解决以下 9 类问题：

| 修改 \ 查询 | 点查询       | 子树查询       | 树链查询       |
|-----------|-------------|---------------|---------------|
| 点修改     | 点修改，点查询 | 点修改，子树查询 | 点修改，树链查询 |
| 子树修改   | 子树修改，点查询 | 子树修改，子树查询 | 子树修改，树链查询 |
| 树链修改   | 树链修改，点查询 | 树链修改，子树查询 | 树链修改，树链查询 |

现在我分九类来进行解释。
1. 点修改，点查询：直接一个数组搞定。
2. 点修改，子树查询：开一个树状数组，然后每次修改就正常在 $in_x$ 上加减，查询就用前缀和减一下即可。
3. 
